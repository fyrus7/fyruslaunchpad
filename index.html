<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Launchpad — 5x6 Pages + Drum (Fixed)</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,sans-serif; background:#0d1014; color:#eaf0fb; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    header { padding:14px 12px; border-bottom:1px solid #1f2736; display:flex; flex-direction:column; gap:10px; align-items:center; background:linear-gradient(180deg,#0d1014cc,#0d1014); position:sticky; top:0; z-index:20; }
    .top-row { width:100%; max-width:980px; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
    .controls { display:flex; gap:8px; align-items:center; }
    .modeBtn, .btn, .pageBtn { padding:8px 12px; border-radius:10px; border:1px solid #2a3648; background:#12161b; color:#eaf0fb; cursor:pointer; }
    .modeBtn.primary { background:#1f5eff; border-color:#2a66ff; }
    .small { font-size:0.92rem; color:#c7d1e6; }
    .pill { padding:6px 10px; border-radius:999px; border:1px solid #2a3445; background:#0f1419; }
    .page-row { width:100%; max-width:980px; margin-top:6px; display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap; }
    main { padding:12px; display:flex; flex-direction:column; align-items:center; gap:14px; }
    /* grid 5 x 6 */
    #padGrid { display:grid; grid-template-columns: repeat(5, 1fr); gap:8px; width:min(760px, 96vw); }
    .pad { display:flex; align-items:center; justify-content:center; border-radius:10px; font-weight:700; background:#151922; border:1px solid #263044; color:#eaf0fb; user-select:none; touch-action:manipulation; padding:6px; min-height:64px; }
    .pad .label { white-space:normal; text-align:center; line-height:1.05; font-size:14px; }
    .pad:active { transform: translateY(1px); filter:brightness(1.12); }
    .pad.flash { box-shadow:0 0 12px rgba(255,160,50,.12); background: linear-gradient(180deg,#26323f,#1a232c); }
    .pad.note { background:linear-gradient(180deg,#12161b,#0f1418); }
    .pad.chord { background:linear-gradient(180deg,#162026,#11161b); }
    .pad.drum { background:linear-gradient(180deg,#251419,#1b0f12); }
    /* layers */
    #layersWrap { width:min(980px,96vw); display:flex; flex-direction:column; gap:8px; }
    .layer { border-radius:10px; padding:10px; background:#0f1419; border:1px solid #222a38; display:flex; flex-direction:column; gap:8px; }
    .layer .top { display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .layer .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .layer button { padding:8px 10px; border-radius:8px; border:1px solid #263044; background:#12161b; color:#eaf0fb; cursor:pointer; }
    .layer button.recording { background: #b52020 !important; color:#fff; animation: blink 1s infinite; border-color:#8f1a1a; }
    .layer button.activeRec { background: #1fa02b !important; color:#fff; border-color:#16761b; }
    @keyframes blink { 0%,50%,100%{opacity:1} 25%,75%{opacity:.5} }
    .muted { color:#9aa6c7; font-size:.92rem; }
    .msg { color:#f2c94c; font-weight:600; margin-left:6px; }
    footer { height:60px; }
    /* responsive tweaks */
    @media (max-width:420px){
      #padGrid { gap:6px; }
      .pad .label { font-size:13px; }
      .pad { min-height:58px; }
    }
  </style>
</head>
<body>

  <header>
    <div class="top-row">
      <div class="controls">
        <button id="modeBtn" class="modeBtn">Mode: Note</button>
        <div style="display:flex;align-items:center;gap:8px;">
          <span class="small muted">Octave</span>
          <button id="octDown" class="btn">−</button>
          <span id="octLabel" class="pill">C3</span>
          <button id="octUp" class="btn">+</button>
        </div>
      </div>
    </div>

    <div class="page-row">
      <div class="pager">
        <button id="prevPage" class="pageBtn">⬅ Prev</button>
        <span id="pageIndicator" class="pill">Page 1</span>
        <button id="nextPage" class="pageBtn">Next ➡</button>
      </div>
      <div style="width:12px"></div>
      <button id="addLayerBtn" class="modeBtn primary">+ Add Layer</button>
    </div>
  </header>

  <main>
    <div id="padGrid" role="grid" aria-label="Launchpad grid"></div>

    <section style="width:min(980px,96vw);">
      <h3 style="margin:6px 0 8px 0">Layers</h3>
      <div id="layersWrap"></div>
    </section>
  </main>

  <footer></footer>

<script>
/* ---------------- Audio / Tone setup ---------------- */
const synth = new Tone.PolySynth(Tone.Synth, {
  maxPolyphony: 32,
  options: { envelope: { attack: 0.005, decay: 0.18, sustain: 0.38, release: 0.6 } }
}).toDestination();

/* ---------------- Config ---------------- */
const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const midiToNote = (m) => `${NOTE_NAMES[m % 12]}${Math.floor(m/12)-1}`;
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

let mode = 'note'; // 'note' | 'chord' | 'drum'
let baseMidi = 48; // C3
const cols = 5, rows = 6;
const padsPerPage = cols * rows; // 30
let currentPage = 0;

/* chord bank */
const chordBank = ["C","Dm","Em","F","G","Am","Bdim","C7","D","E","Fmaj7","G7","A7","B7","Cm","Dm7","Em7","Fm","Gm","Am","Bm","Cmaj7","D7","E7","F6","G6","A6","B6","C6","D6","E6","F#7","G#7","A#7","Bdim7","C9","D9","E9","F9","G9"];

/* drum kit (filenames inside samples/) */
const drumKit = [
  "kick.wav","snare.wav","hihat_closed.wav","hihat_open.wav",
  "clap.wav","perc.wav","tom_low.wav","tom_mid.wav",
  "tom_high.wav","rim.wav","ride.wav","shaker.wav",
  "crash.wav","fx1.wav","fx2.wav","fx3.wav"
];

let drumBuffers = {}; // filename -> AudioBuffer
let drumLoaded = false;

async function loadDrumSamples(){
  try {
    for (const f of drumKit){
      const url = `samples/${f}`;
      try {
        const r = await fetch(url);
        if (!r.ok) { console.warn('Sample missing', url); continue; }
        const ab = await r.arrayBuffer();
        const decoded = await Tone.context.rawContext.decodeAudioData(ab);
        drumBuffers[f] = decoded;
      } catch(e){
        console.warn('Failed to load sample', f, e);
      }
    }
    drumLoaded = true;
    console.log('Drum samples load attempted');
  } catch(e){
    console.warn('Drum load overall failed', e);
  }
}
loadDrumSamples();

/* ---------------- Grid / Paging ---------------- */
const padGrid = document.getElementById('padGrid');
const pageIndicator = document.getElementById('pageIndicator');
const modeBtn = document.getElementById('modeBtn');
const octLabel = document.getElementById('octLabel');
const octDown = document.getElementById('octDown');
const octUp = document.getElementById('octUp');
const prevPageBtn = document.getElementById('prevPage');
const nextPageBtn = document.getElementById('nextPage');
const addLayerBtn = document.getElementById('addLayerBtn');

function updateOctLabel(){ octLabel.textContent = midiToNote(baseMidi); }
updateOctLabel();

octDown.addEventListener('click', ()=> { baseMidi = clamp(baseMidi-12, 24, 84); updateOctLabel(); renderGrid(); });
octUp.addEventListener('click', ()=> { baseMidi = clamp(baseMidi+12, 24, 84); updateOctLabel(); renderGrid(); });

modeBtn.addEventListener('click', () => {
  if (mode === 'note') mode = 'chord';
  else if (mode === 'chord') mode = 'drum';
  else mode = 'note';
  modeBtn.textContent = `Mode: ${mode.charAt(0).toUpperCase()+mode.slice(1)}`;
  currentPage = 0;
  renderGrid();
});

function totalPagesForMode(){
  if (mode === 'note') { const totalNotes = 72; return Math.ceil(totalNotes / padsPerPage); }
  if (mode === 'chord') { return Math.ceil(chordBank.length / padsPerPage); }
  return Math.ceil(Math.max(drumKit.length, 1) / padsPerPage);
}

prevPageBtn.addEventListener('click', ()=>{ if (currentPage>0) currentPage--; renderGrid(); });
nextPageBtn.addEventListener('click', ()=>{ if (currentPage < totalPagesForMode()-1) currentPage++; renderGrid(); });

/* ---------------- Play functions ---------------- */
async function ensureAudioStarted(){ try{ await Tone.start(); }catch{} }

function flashPad(el){
  if(!el) return;
  el.classList.add('flash');
  setTimeout(()=> el.classList.remove('flash'), 140);
}

function playNote(note, whenSec = 0, dur = 0.25){
  synth.triggerAttackRelease(note, dur + "s", Tone.now() + whenSec);
  layers.forEach(L => { if (L.isRecording) { const t = performance.now() - L.recStartTime; L.events.push({ time: t, type: 'note', value: note, dur }); L.msg = ''; } });
}

function getChordNotes(chord) {
  const map = {
    "C":["C4","E4","G4"], "Dm":["D4","F4","A4"], "Em":["E4","G4","B4"], "F":["F4","A4","C5"],
    "G":["G4","B4","D5"], "Am":["A4","C5","E5"], "Bdim":["B4","D5","F5"], "C7":["C4","E4","G4","A#4"],
    "Cm":["C4","D#4","G4"], "Dm7":["D4","F4","A4","C5"], "Em7":["E4","G4","B4","D5"]
  };
  return map[chord] || null;
}
function playChordName(chordName, whenSec = 0, dur = 1.0){
  const notes = getChordNotes(chordName);
  if (notes) {
    synth.triggerAttackRelease(notes, dur + "s", Tone.now() + whenSec);
  } else {
    // if unknown chord name, try to play it as single note string
    try { synth.triggerAttackRelease(chordName, dur + "s", Tone.now() + whenSec); } catch(e){ console.warn('Unknown chord', chordName); }
  }
  layers.forEach(L => { if (L.isRecording) { const t = performance.now() - L.recStartTime; L.events.push({ time: t, type: 'chord', value: chordName, dur }); L.msg = ''; } });
}

function playDrumByFilename(fname, whenSec = 0){
  const buf = drumBuffers[fname];
  layers.forEach(L => { if (L.isRecording) { const t = performance.now() - L.recStartTime; L.events.push({ time: t, type: 'drum', value: fname }); L.msg = ''; } });
  if (!buf) return; // silent if missing
  // schedule using AudioContext.currentTime (Tone.context.rawContext.currentTime)
  const startAt = Tone.context.rawContext.currentTime + whenSec;
  const src = Tone.context.rawContext.createBufferSource();
  src.buffer = buf;
  src.connect(Tone.context.rawContext.destination);
  src.start(startAt);
}

/* ---------------- Render Grid per page ---------------- */
function renderGrid(){
  padGrid.innerHTML = '';
  const pages = totalPagesForMode();
  if (currentPage < 0) currentPage = 0;
  if (currentPage >= pages) currentPage = pages-1;
  pageIndicator.textContent = `Page ${currentPage+1}`;

  if (mode === 'note') {
    const totalNotes = 72;
    const globalStart = baseMidi - 12;
    const startIndex = currentPage * padsPerPage;
    for (let i=0;i<padsPerPage;i++){
      const globalIdx = startIndex + i;
      const midi = globalStart + globalIdx;
      const note = midiToNote(midi);
      const btn = document.createElement('button');
      btn.className = 'pad note';
      btn.innerHTML = `<div class="label">${note}</div>`;
      btn.onclick = async () => { await ensureAudioStarted(); flashPad(btn); playNote(note); };
      padGrid.appendChild(btn);
    }
  } else if (mode === 'chord') {
    const start = currentPage * padsPerPage;
    for (let i=0;i<padsPerPage;i++){
      const idx = start + i;
      const chordName = chordBank[idx % chordBank.length];
      const btn = document.createElement('button');
      btn.className = 'pad chord';
      btn.innerHTML = `<div class="label">${chordName}</div>`;
      btn.onclick = async () => { await ensureAudioStarted(); flashPad(btn); playChordName(chordName); };
      padGrid.appendChild(btn);
    }
  } else { // drum
    const start = currentPage * padsPerPage;
    for (let i=0;i<padsPerPage;i++){
      const idx = (start + i) % drumKit.length;
      const filename = drumKit[idx];
      const label = filename.replace(/\.[^/.]+$/, "");
      const btn = document.createElement('button');
      btn.className = 'pad drum';
      // label can be long — allow wrap into two lines
      btn.innerHTML = `<div class="label">${label}</div>`;
      btn.onclick = async () => { await ensureAudioStarted(); flashPad(btn); playDrumByFilename(filename); };
      padGrid.appendChild(btn);
    }
  }
}

/* initial render */
renderGrid();

/* ---------------- Layers (unlimited) ---------------- */
let layers = [];
let idCounter = 0;
const layersWrap = document.getElementById('layersWrap');

addLayerBtn.addEventListener('click', addLayer);

function addLayer(){
  const id = `L${++idCounter}`;
  const layer = {
    id,
    name: `Layer ${layers.length+1}`,
    events: [],
    isRecording: false,
    isPlaying: false,
    recStartTime: 0,
    loopLengthMs: 0,
    timers: [],
    msg: ''
  };
  layers.push(layer);
  renderLayers();
}

function renderLayers(){
  layersWrap.innerHTML = '';
  layers.forEach((L, idx) => {
    const el = document.createElement('div');
    el.className = 'layer';
    el.id = L.id;

    el.innerHTML = `
      <div class="top">
        <div style="display:flex;gap:12px;align-items:center;">
          <div style="font-weight:700">${L.name}</div>
          <div class="muted">${L.events.length} event${L.events.length!==1?'s':''}</div>
          ${L.msg ? `<div class="msg" id="${L.id}-msg">${L.msg}</div>` : ''}
        </div>
        <div class="muted small">Loop: <span id="${L.id}-loop">—</span></div>
      </div>
      <div class="controls">
        <button data-act="record" data-id="${L.id}">● Record</button>
        <button data-act="stoprec" data-id="${L.id}">■ Stop</button>
        <button data-act="play" data-id="${L.id}">▶ Play</button>
        <button data-act="stopplay" data-id="${L.id}">⏹ Stop</button>
        <button data-act="clear" data-id="${L.id}">⟲ Clear</button>
        <button data-act="delete" data-id="${L.id}">✖ Delete</button>
      </div>
    `;
    layersWrap.appendChild(el);

    // style record button state
    const recBtn = el.querySelector('[data-act="record"]');
    if (L.isRecording) recBtn.classList.add('recording');
    else if (L.events.length > 0) recBtn.classList.add('activeRec');
  });
}

/* Delegate click actions in layersWrap */
layersWrap.addEventListener('click', (ev) => {
  const btn = ev.target.closest('button[data-act]');
  if (!btn) return;
  const act = btn.dataset.act;
  const id = btn.dataset.id;
  const L = layers.find(x => x.id === id);
  if (!L) return;

  if (act === 'record') startRecord(L);
  if (act === 'stoprec') stopRecord(L);
  if (act === 'play') startPlay(L);
  if (act === 'stopplay') stopPlay(L);
  if (act === 'clear') clearLayer(L);
  if (act === 'delete') deleteLayer(L);
});

/* Recording */
function startRecord(L){
  clearScheduled(L);
  L.events = [];
  L.isRecording = true;
  L.recStartTime = performance.now();
  L.msg = '';
  setLoopLabel(L, 'recording…');
  renderLayers();
}
function stopRecord(L){
  L.isRecording = false;
  if (L.events.length > 0){
    const last = L.events[L.events.length - 1].time;
    L.loopLengthMs = Math.max(1000, last + 500);
  } else L.loopLengthMs = 0;
  setLoopLabel(L, L.loopLengthMs ? (Math.round(L.loopLengthMs)/1000 + 's') : '—');
  renderLayers();
}

/* Playback scheduling — use Tone.now() scheduling for accuracy */
function startPlay(L){
  if (L.events.length === 0){
    L.msg = 'Layer kosong';
    renderLayers();
    return;
  }
  if (L.isPlaying) return;
  L.isPlaying = true;
  L.msg = '';
  scheduleLayer(L);
  renderLayers();
}
function stopPlay(L){
  L.isPlaying = false;
  clearScheduled(L);
  renderLayers();
}

function scheduleLayer(L){
  clearScheduled(L);
  const loopMs = L.loopLengthMs || (L.events[L.events.length-1].time + 500);
  const baseAudioTime = Tone.now();
  // schedule events immediately via Tone context (accurate)
  for (const ev of L.events){
    const evSec = ev.time / 1000;
    if (ev.type === 'note') {
      try { synth.triggerAttackRelease(ev.value, (ev.dur ?? 0.25) + "s", baseAudioTime + evSec); }
      catch(e){ console.warn('play note schedule fail', e); }
    } else if (ev.type === 'chord') {
      const notes = getChordNotes(ev.value);
      if (notes) synth.triggerAttackRelease(notes, (ev.dur ?? 1.0) + "s", baseAudioTime + evSec);
      else {
        try { synth.triggerAttackRelease(ev.value, (ev.dur ?? 1.0) + "s", baseAudioTime + evSec); }
        catch(e){ console.warn('unknown chord during schedule', ev.value); }
      }
    } else if (ev.type === 'drum') {
      const buf = drumBuffers[ev.value];
      if (buf){
        const src = Tone.context.rawContext.createBufferSource();
        src.buffer = buf;
        src.connect(Tone.context.rawContext.destination);
        src.start(Tone.context.rawContext.currentTime + evSec);
      } // if missing, skip sound but event logic already recorded
    }
  }

  // push a single loop timeout to re-run schedule
  const loopHandle = setTimeout(() => {
    if (L.isPlaying) scheduleLayer(L);
  }, loopMs);
  L.timers.push(loopHandle);
}

function clearScheduled(L){
  L.timers.forEach(h => clearTimeout(h));
  L.timers = [];
}

/* Utilities for layers */
function clearLayer(L){
  stopPlay(L);
  L.events = [];
  L.loopLengthMs = 0;
  L.msg = '';
  setLoopLabel(L, '—');
  renderLayers();
}

function deleteLayer(L){
  stopPlay(L);
  layers = layers.filter(x => x.id !== L.id);
  renderLayers();
}

function setLoopLabel(L, txt){
  const el = document.getElementById(`${L.id}-loop`);
  if (el) el.textContent = txt;
}

/* ---------------- Keyboard small mapping ---------------- */
const keyMap = ['z','x','c','v','b','n','m','q','w','e','r','t','y','u','i','o'];
window.addEventListener('keydown', async (ev) => {
  if (ev.repeat) return;
  const k = ev.key.toLowerCase();
  const idx = keyMap.indexOf(k);
  if (idx === -1) return;
  const pageStart = currentPage * padsPerPage;
  if (mode === 'note'){
    const midi = baseMidi - 12 + pageStart + idx;
    const note = midiToNote(midi);
    await ensureAudioStarted();
    playNote(note);
  } else if (mode === 'chord'){
    const name = chordBank[(currentPage * padsPerPage + idx) % chordBank.length];
    await ensureAudioStarted();
    playChordName(name);
  } else {
    const fname = drumKit[(currentPage * padsPerPage + idx) % drumKit.length];
    await ensureAudioStarted();
    playDrumByFilename(fname);
  }
});

/* ---------------- Init with one layer ---------------- */
addLayer();

</script>
</body>
</html>
